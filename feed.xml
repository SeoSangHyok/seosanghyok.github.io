<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-08-02T14:11:25+00:00</updated><id>/feed.xml</id><title type="html">My Dev / Study Archive</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>Seo Sang Hyok</name></author><entry><title type="html">공유기 외부접속 세팅</title><link href="/network/2023/07/31/%EA%B3%B5%EC%9C%A0%EA%B8%B0_%EC%99%B8%EB%B6%80%EC%A0%91%EC%86%8D_%EC%84%B8%ED%8C%85.html" rel="alternate" type="text/html" title="공유기 외부접속 세팅" /><published>2023-07-31T00:00:00+00:00</published><updated>2023-07-31T00:00:00+00:00</updated><id>/network/2023/07/31/%EA%B3%B5%EC%9C%A0%EA%B8%B0_%EC%99%B8%EB%B6%80%EC%A0%91%EC%86%8D_%EC%84%B8%ED%8C%85</id><content type="html" xml:base="/network/2023/07/31/%EA%B3%B5%EC%9C%A0%EA%B8%B0_%EC%99%B8%EB%B6%80%EC%A0%91%EC%86%8D_%EC%84%B8%ED%8C%85.html"><![CDATA[<p>네트워크나 서버 프로그래밍, DB공부, 개인 파일서버나 원격접속등 외부에서 내 컴퓨터에 접근해야 할일은 상당히 많다. 만약 우리집에 있는 로컬컴퓨터에 원격 데스크탑이 가능하도록 세팅했다고 하자. 그리고 까패나 다른 곳에서 일이 생겨 내 컴퓨터에 원격으로 붙어야 할때 어떻게 하면 될까?</p>

<h2 id="일단-그냥-한번-해보자">일단 그냥 한번 해보자</h2>

<p>원격 데스크탑 세팅이 가능한 사람이라면 CMD(명령프롬프트)창에서 <strong>ipconfig</strong> 명령을 이용해서 자신의 IP정도는 쉽게 확인 할 수 있을것이다. 만약 집이고 공유기를 이용해서 인터넷을 연결중이라면 노트북등 다른 컴퓨터에서 원격으로 붙는것도 손쉽게 가능할 것이다.</p>

<p><img src="/assets/images/2023/07/2023-07-31/01.png" alt="ip확인" /></p>

<p><img src="/assets/images/2023/07/2023-07-31/02.png" alt="원격연결1" /></p>

<p><img src="/assets/images/2023/07/2023-07-31/03.png" alt="원격연결2" /></p>

<h3 id="그런대-만약-다른곳에서-똑같이-한다면">그런대 만약 다른곳에서 똑같이 한다면??</h3>

<p>만약 까페의 인터넷 을 사용하거나 인터넷이 안되는 환경에서 휴대폰 테더링을 통해 인터넷을 하고 있는경우 위에서 한거처럼 똑같은 ip를 넣고 접속이 가능할까?? 당장 까페에 가서 테스트해보자. 굳이 까페에 가지 않더라도 노트북이 있다면 휴대폰 등으로 노트북을 테더링 연결 후 해보자.</p>

<h2 id="왜-안되는-걸까">왜 안되는 걸까??</h2>

<p>바깥에 까페등 다른곳에서 인터넷을 연결한 후 시도한다면 연결이 되지 않을것이다. 왜 안될까?? 아마 대부분 집과 까페에 인터넷을 연결하는 상황은 아래와 같을것이다.</p>

<p><img class="plantuml" src="http://www.plantuml.com/plantuml/svg/~h407374617274756d6c0a407374617274756d6c0a636c6f756420494e5445524e45540a6e6f64652022eca7912220617320486f6d65207b0a636f6d706f6e656e742022ebaaa8eb8e802220617320485f6d6f64656d0a636f6d706f6e656e742022eab3b5ec9ca0eab8b02220617320485f4e41540a72656374616e676c652022ecbbb4ed93a8ed84b05c6e283139322e3136382e302e3531292220617320485f436f6d0a72656374616e676c652022eb85b8ed8ab8ebb6812220617320485f6e6f74650a72656374616e676c652022ed9cb4eb8c80ed8fb02220617320485f70686f6e650a0a485f6d6f64656d202d2d20485f4e41540a485f4e4154202d2d20485f436f6d0a485f4e4154202d2d20485f6e6f74650a485f4e4154202d2d20485f70686f6e650a7d0a0a6e6f6465202263616665222061732043616665207b0a636f6d706f6e656e742022eab3b5ec9ca0eab8b02220617320435f4e41540a6e6f7465206c656674206f6620435f4e41540a20202020eab3b5ec9ca0eab8b0ec998020ebaaa8eb8e80200a20202020eab8b0eb8aa5ec9db420ed9598eb8298ec9790200a20202020eab099ec9db420ec9e88eb8a94200a20202020eab2bdec9ab0eb8f8420ec9e88eb8ba42e0a656e64206e6f74650a72656374616e676c652022eb85b8ed8ab8ebb681312220617320435f6e6f7465310a72656374616e676c652022eb85b8ed8ab8ebb681322220617320435f6e6f7465320a72656374616e676c6520222e2e2e2220617320435f6574630a0a435f4e4154202d2d20435f6e6f7465310a435f4e4154202d2d20435f6e6f7465320a435f4e4154202d2d20435f6574630a7d0a0a494e5445524e4554202d2d20485f6d6f64656d0a494e5445524e4554202d2d20435f4e41540a0a40656e64756d6c0a40656e64756d6c" /></p>

<p>이것을 도식화 하면 아래와 같다.</p>

<p><img class="plantuml" src="http://www.plantuml.com/plantuml/svg/~h407374617274756d6c0a407374617274756d6c0a21696e636c756465203c6f66666963652f436f6d6d756e69636174696f6e732f736d735f676174657761793e0a21696e636c756465203c6f66666963652f436f6d6d756e69636174696f6e732f736d74705f636f6e6e6563746f723e0a21696e636c756465203c6f66666963652f436f6d6d756e69636174696f6e732f766f69705f676174657761793e0a21696e636c756465203c6f66666963652f446576696365732f6d6f64656d3e0a21696e636c756465203c6f66666963652f446576696365732f776f726b73746174696f6e3e0a21696e636c756465203c6f66666963652f446576696365732f63656c6c5f70686f6e655f67656e657269633e0a21696e636c756465203c6f66666963652f446576696365732f6465766963655f6c6170746f703e0a0a6e7764696167207b0a20206e6574776f726b20496e7465726e6574207b0a20202020486f6d65526f75746572205b61646472657373203d20223c623e3c636f6c6f723a233030303066663e3131392e3135382e3230302e3134353c2f636f6c6f723e3c2f623e222c206465736372697074696f6e203d20223c24766f69705f676174657761793e5c6eec9db8ed84b0eb84b7ebaaa8eb8e80225d0a2020202043616665526f75746572205b61646472657373203d20223c623e3c636f6c6f723a233030303066663e3138372e3234352e3133312e3131323c2f636f6c6f723e3c2f623e222c206465736372697074696f6e203d20223c246d6f64656d3e5c6eeab98ced8ca8eab3b5ec9ca0eab8b05c6e28ebaaa8eb8e80eab3bc20eab3b5ec9ca0eab8b0eab0805c6eec9dbcecb2b4ed9895ec9db820eab2bdec9ab0eb8f8420ec9e88eb8ba42e29225d0a20207d0a2020486f6d65526f75746572202d2d20486f6d654e41540a2020486f6d654e4154205b61646472657373203d20223c623e3c636f6c6f723a236666303030303e3139322e3136382e302e313c2f636f6c6f723e3c2f623e222c206465736372697074696f6e203d20223c246d6f64656d3e5c6eeca791eab3b5ec9ca0eab8b0225d0a20200a20206e6574776f726b20486f6d65207b0a20202020486f6d654e41540a20202020486f6d65436f6d31205b61646472657373203d20223c623e3c636f6c6f723a236666303030303e3139322e3136382e302e35303c2f636f6c6f723e3c2f623e222c206465736372697074696f6e203d20223c24776f726b73746174696f6e3e5c6eeb8db0ec8aa4ed81aced8391225d0a20202020486f6d65436f6d32205b61646472657373203d20223139322e3136382e302e3730222c206465736372697074696f6e203d20223c246465766963655f6c6170746f703e5c6eeb85b8ed8ab8ebb681225d0a20202020486f6d65436f6d33205b61646472657373203d20223139322e3136382e302e3738222c206465736372697074696f6e203d20223c2463656c6c5f70686f6e655f67656e657269633e5c6eed9cb4eb8c80ed8fb0225d0a20207d0a0a20206e6574776f726b2043616665207b0a2020202043616665526f75746572205b61646472657373203d20223c623e3c636f6c6f723a236666303030303e3139322e3136382e302e313c2f636f6c6f723e3c2f623e225d0a2020202043616665436f6d31205b61646472657373203d20223139322e3136382e302e3330222c206465736372697074696f6e203d20223c24776f726b73746174696f6e3e5c6eeb8db0ec8aa4ed81aced8391225d0a2020202043616665436f6d32205b61646472657373203d20223c623e3c636f6c6f723a236666303030303e3139322e3136382e302e35303c2f636f6c6f723e3c2f623e222c206465736372697074696f6e203d20223c246465766963655f6c6170746f703e5c6eeb85b8ed8ab8ebb68131225d0a2020202043616665436f6d33205b61646472657373203d20223139322e3136382e302e3735222c206465736372697074696f6e203d20223c246465766963655f6c6170746f703e5c6eeb85b8ed8ab8ebb68132225d0a20207d0a20200a202067726f7570207b0a202020206465736372697074696f6e203d2022eca79120eb84a4ed8ab8ec9b8ced81ac220a20202020486f6d65526f757465723b0a20202020486f6d654e41543b0a20202020486f6d65436f6d313b0a20202020486f6d65436f6d323b0a20202020486f6d65436f6d333b0a20207d0a0a202067726f7570207b0a202020206465736372697074696f6e203d2022eab98ced8e9820eb84a4ed8ab8ec9b8ced81ac220a2020202043616665526f757465723b0a2020202043616665436f6d313b0a2020202043616665436f6d323b0a2020202043616665436f6d333b0a20207d0a7d0a40656e64756d6c0a40656e64756d6c" /></p>

<p>여기서 인터넷 망은 모뎀 혹은 공유기에 연결되며 PC나 휴대론은 공유기에 연결되서 인터넷에 연결된다. 여기서 집 모뎀과 카페 공유기는 각각 <strong>카페 공유기 네트워크 망</strong>, <strong>집 공유기 네트워크 망</strong> 으로 각각 독립된 네트워크다.(LAN 망이라고도 한다.)</p>

<h3 id="각각의-네트워크-망은-내부ip를-이용해서-통신한다">각각의 네트워크 망은 내부IP를 이용해서 통신한다.</h3>

<p>위 그림에서 붉은색으로 표시된 IP는 집과 까페 네트워크에 중복해서 있는것을 볼 수 있다. 내부 내트워크 망에서서는 장비를 구분하기 위해 내부 IP주소를 사용하며 이 IP는 말그대로 내부 네트워크에서 사용되는 것이기 대문에 네트워크가 다르다면 중복가능하다. 즉 집과 까페에서 <strong>192.168.0.50</strong> ip 주소의 장비는 다른 장비다. 그렇기 때문에 집에서는 동작하는 원격이나 서버 접속이 다른곳에서 하면 안되는 것이다.</p>

<h3 id="어-그럼-네이버에서-ip찾기한담에-그걸로-접속하면-되겠내요">어?! 그럼 네이버에서 ip찾기한담에 그걸로 접속하면 되겠내요?</h3>

<p>위에서 파란색으로 표시된 ip주소가 우리집 혹은 까페의 네트워크 IP주소이며 네이버에서 <strong>내 ip확인</strong> 등으로 확인할 수 있다. 그러면 “어?! 저주소로 접속하면 되는거 아냐??” 라고 생각할 수 있다. 하지만 위 도식을 보자. 푸른색 ip로 지정된 네트워크 밑에 컴퓨터 노트북 휴대폰등 여러장비가 연결되어 있다. 그럼 저 IP로 접속했을 때 어디로 접속해야 할까?? 모호해진다. 여기서 IP주소 이외에 포트(PORT) 라는 개념이 등장한다.</p>

<h2 id="port">PORT</h2>

<p>위에서 IP주소로 네트워크에 접속한 장비 자체의 주소를 판단할 수 있다고 했다. 쉽게 포트는 네트워트에 접속한 장비에서 실행되는 프로그램에 접속할 수 있는 주소라고 보면 된다. 우리가 네트워크 를 통해 원격 데스크탑을 이용하는것을 예로 들어보자. 원격 데스크탑 역시 프로그램이다. 다른 장비에서 원격 데스크탑을 이용한다는 것은 다른 의미로 <strong>어떤 장비(IP)에 실행중인 원격 데스크탑 프로그램에 접속</strong>한다는 것을 의미한다. (원격도 하나의 프로그램이다.) 여기서 어떤 프로그램 을 구분할 수 있는 내용이 포트(PORT)다. 즉 어떤 장비(IP)의 어떤 프로그램(PORT) 에 접속 하는것. 그러면 위 도식은 아래와 같이 확장될 수 있다.</p>

<p><img class="plantuml" src="http://www.plantuml.com/plantuml/svg/~h407374617274756d6c0a407374617274756d6c0a21696e636c756465203c6f66666963652f436f6d6d756e69636174696f6e732f736d735f676174657761793e0a21696e636c756465203c6f66666963652f436f6d6d756e69636174696f6e732f736d74705f636f6e6e6563746f723e0a21696e636c756465203c6f66666963652f436f6d6d756e69636174696f6e732f766f69705f676174657761793e0a21696e636c756465203c6f66666963652f446576696365732f6d6f64656d3e0a21696e636c756465203c6f66666963652f446576696365732f776f726b73746174696f6e3e0a21696e636c756465203c6f66666963652f446576696365732f63656c6c5f70686f6e655f67656e657269633e0a21696e636c756465203c6f66666963652f446576696365732f6465766963655f6c6170746f703e0a0a6e7764696167207b0a20206e6574776f726b20496e7465726e6574207b0a20202020486f6d65526f75746572205b61646472657373203d20223c623e3c636f6c6f723a233030303066663e3131392e3135382e3230302e3134353c2f636f6c6f723e3c2f623e222c206465736372697074696f6e203d20223c24766f69705f676174657761793e5c6eec9db8ed84b0eb84b7ebaaa8eb8e80225d0a2020202043616665526f75746572205b61646472657373203d20223c623e3c636f6c6f723a233030303066663e3138372e3234352e3133312e3131323c2f636f6c6f723e3c2f623e222c206465736372697074696f6e203d20223c246d6f64656d3e5c6eeab98ced8ca8eab3b5ec9ca0eab8b05c6e28ebaaa8eb8e80eab3bc20eab3b5ec9ca0eab8b0eab0805c6eec9dbcecb2b4ed9895ec9db820eab2bdec9ab0eb8f8420ec9e88eb8ba42e29225d0a20207d0a2020486f6d65526f75746572202d2d20486f6d654e41540a2020486f6d654e4154205b61646472657373203d20223c623e3c636f6c6f723a236666303030303e3139322e3136382e302e313c2f636f6c6f723e3c2f623e222c206465736372697074696f6e203d20223c246d6f64656d3e5c6eeca791eab3b5ec9ca0eab8b0225d0a20200a20206e6574776f726b20486f6d65207b0a20202020486f6d654e41540a20202020486f6d65436f6d31205b61646472657373203d20223c623e3c636f6c6f723a236666303030303e3139322e3136382e302e35303c2f636f6c6f723e3c2f623e222c206465736372697074696f6e203d20223c24776f726b73746174696f6e3e5c6eeb8db0ec8aa4ed81aced8391225d0a20202020486f6d65436f6d32205b61646472657373203d20223139322e3136382e302e3730222c206465736372697074696f6e203d20223c246465766963655f6c6170746f703e5c6eeb85b8ed8ab8ebb681225d0a20202020486f6d65436f6d33205b61646472657373203d20223139322e3136382e302e3738222c206465736372697074696f6e203d20223c2463656c6c5f70686f6e655f67656e657269633e5c6eed9cb4eb8c80ed8fb0225d0a20207d0a2020486f6d65436f6d31202d2d2072656d6f74654170703b0a2020486f6d65436f6d32202d2d20736572764170703b0a202072656d6f7465417070205b61646472657373203d20223139322e3136382e302e37383a2a2a333338392a2a222c206465736372697074696f6e203d2022ec9b90eab2a9eb8db0ec8aa4ed81aced8391222c20636f6c6f72203d206f72616e67655d3b0a202073657276417070205b61646472657373203d20223139322e3136382e302e37383a2a2a393938372a2a222c206465736372697074696f6e203d2022ec849cebb284ed9484eba19ceab7b8eb9ea8222c20636f6c6f72203d206f72616e67655d3b0a0a20206e6574776f726b2043616665207b0a2020202043616665526f75746572205b61646472657373203d20223c623e3c636f6c6f723a236666303030303e3139322e3136382e302e313c2f636f6c6f723e3c2f623e225d0a2020202043616665436f6d31205b61646472657373203d20223139322e3136382e302e3330222c206465736372697074696f6e203d20223c24776f726b73746174696f6e3e5c6eeb8db0ec8aa4ed81aced8391225d0a2020202043616665436f6d32205b61646472657373203d20223c623e3c636f6c6f723a236666303030303e3139322e3136382e302e35303c2f636f6c6f723e3c2f623e222c206465736372697074696f6e203d20223c246465766963655f6c6170746f703e5c6eeb85b8ed8ab8ebb68131225d0a2020202043616665436f6d33205b61646472657373203d20223139322e3136382e302e3735222c206465736372697074696f6e203d20223c246465766963655f6c6170746f703e5c6eeb85b8ed8ab8ebb68132225d0a20207d0a20200a202067726f7570207b0a202020206465736372697074696f6e203d2022eca79120eb84a4ed8ab8ec9b8ced81ac220a20202020486f6d65526f757465723b0a20202020486f6d654e41543b0a20202020486f6d65436f6d313b0a20202020486f6d65436f6d323b0a20202020486f6d65436f6d333b0a20207d0a0a202067726f7570207b0a202020206465736372697074696f6e203d2022eab98ced8e9820eb84a4ed8ab8ec9b8ced81ac220a2020202043616665526f757465723b0a2020202043616665436f6d313b0a2020202043616665436f6d323b0a2020202043616665436f6d333b0a20207d0a7d0a40656e64756d6c0a40656e64756d6c" /></p>

<p>포트는 공유기 PC모두 각각 각 장비마다 0~65565 번까지 가질 수 있다. 여기서 0~49151 번은 이미 예약된 포트로 생각하면 되며 일반적인 경우 49152~65535 까지를 일반 유저가 사용하는것이 좋다.</p>

<h2 id="먼가-외부에서-접속할-수-있는-방법이-보인다">먼가 외부에서 접속할 수 있는 방법이 보인다…</h2>

<p>네트워크 망의 ip주소와 내부 ip에서 실행중인 프로그램을 구분까지 할 수 있게 되었다. 그러면 아래 방법으로 외부에서 노트북으로 집에 있는 내 컴퓨터에 원격접속할 수 있지 않을까?? 가능하다. 공유기의 기능중 공유기 ip의 특정 포트로 접속한 경우 내부 네트워크의 특정 포트로 연결하는 <strong>포트 포워딩</strong>이라는 기능을 이용하면 접속가능하다.</p>

<p><img class="plantuml" src="http://www.plantuml.com/plantuml/svg/~h407374617274756d6c0a407374617274756d6c0a21696e636c756465203c6f66666963652f436f6d6d756e69636174696f6e732f736d735f676174657761793e0a21696e636c756465203c6f66666963652f436f6d6d756e69636174696f6e732f736d74705f636f6e6e6563746f723e0a21696e636c756465203c6f66666963652f436f6d6d756e69636174696f6e732f766f69705f676174657761793e0a21696e636c756465203c6f66666963652f446576696365732f6d6f64656d3e0a21696e636c756465203c6f66666963652f446576696365732f776f726b73746174696f6e3e0a21696e636c756465203c6f66666963652f446576696365732f63656c6c5f70686f6e655f67656e657269633e0a21696e636c756465203c6f66666963652f446576696365732f6465766963655f6c6170746f703e0a0a6167656e7420223c246465766963655f6c6170746f703e5c6eeb85b8ed8ab8ebb6812220617320636f6d310a636c6f756420696e7465726e65740a6167656e7420223c246d6f64656d3e5c6eeab3b5ec9ca0eab8b05c6e49503a3131392e3135382e3230302e31343522206173204e41540a6167656e7420223c24776f726b73746174696f6e3e5c6eeca79120ecbbb4ed93a8ed84b05c6e49503a3139322e3136382e302e35302220617320636f6d320a6167656e742022ec9b90eab2a920eb8db0ec8aa4ed81aced83915c6e506f72743a33333839222061732072656d6f74654170700a0a636f6d31202d722d3e20696e7465726e6574203a203131392e3135382e3230302e3134353a35303030315c6eec9cbceba19c20eca091ec868d0a696e7465726e6574202d722d3e204e41540a4e4154202d722d3e20636f6d32203a20353030303120ebb28820ed8faced8ab8eba19c20eca091ec868dec9d8420ec8b9ceb8f84ed959ceab2bdec9ab05c6ceca79120ecbbb4ed93a8ed84b0ec9d9820ec9b90eab2a920eb8db0ec8aa4ed81aced839120ed8faced8ab8283333383929eba19c20ec97b0eab2b00a636f6d32202d642d3e2072656d6f74654170700a0a40656e64756d6c0a40656e64756d6c" /></p>

<h2 id="포트포워딩-세팅을-해보자">포트포워딩 세팅을 해보자</h2>

<p>필자가 가지고 있는 공유기가 iptime 것이라 iptime을 기준으로 설명한다.</p>

<h3 id="공유기-설정-패이지-접속">공유기 설정 패이지 접속</h3>

<p>우선 브라우저를 실행 후 주소에 <strong>192.168.0.1</strong> 을 입력해보자. 공유기 설정 패이지가 출력될 것이다. 공유기 설정 주소는 제조사 마다 다를 수 있기때문에 tplink 등 다른 공유기를 사용하고 있으면 설정 패이지에 들어가는 주소는 메뉴얼이나 검색해서 알아내도록 한다.</p>

<p><img src="/assets/images/2023/07/2023-07-31/04.png" alt="iptime 공유기 설정주소" /></p>

<p><img src="/assets/images/2023/07/2023-07-31/05.png" alt="iptime 공유기 설정패이지" /></p>

<p>설정페이지에서 로그인 후 관리도구로 들어가면 위 그림과 같은 현제 공유기의 외부ip(붉은색 사각형 으로표시된 부분)등 공유기 현재 상태에대한 정보를 확인 할 수 있다. 외부ip의 경우 네이버등 포털에서 “내 ip 찾기”로 확인한 ip와 동일하다.</p>

<h3 id="포트-포워딩-설정-항목-진입">포트 포워딩 설정 항목 진입</h3>

<p>공유기의 [NAT/라우터 관리] 항목에서 [포트포워드 설정] 항목으로 들어간다. 여기서 [새 규칙] 을 통해 포트포워드 규칙을 추가한다.</p>

<ul>
  <li>규칙이름
    <ul>
      <li>규칙이름은 내가 알기쉽게 정한다. 여기선 TEST_Remote_Outer라고 세팅한다.</li>
    </ul>
  </li>
  <li>내부 IP주소
    <ul>
      <li>포트포워딩을 통해 내가 접속하고자 하는 내부 장비의 IP를 지칭한다.</li>
      <li>위에서 확인한 컴퓨터 주소는 192.168.0.72 였다.</li>
    </ul>
  </li>
  <li>외부 포트 / 내부포트
    <ul>
      <li>외부포트 와 내부포트는 외부ip의 외부포트로 접속하면 이를 내부ip의 내부포트로 전환시키겠다는 의미다. 즉 현제 공유기 외부ip인 <strong>210.2.43.119 의 50001 번 포트로 접속</strong>하면 이를 내부ip <strong>192.168.0.72 의 3389번 포트</strong> 에 접속한것과 동일하게 처리하겠다 라는 의미이다.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/images/2023/07/2023-07-31/06.png" alt="포트포워딩 세팅" /></p>

<p>규칙을 적용했으면 이제 테스트해보자</p>

<h3 id="포트포워딩을-이용한-외부접속">포트포워딩을 이용한 외부접속</h3>

<p>아까와 같이 원격접속을 해본다. 하지만 이번엔 내부ip로 접속하는것이 아니라 아까 포트포워딩 세팅한 210.2.43.119:50001 로 접속해본다.</p>

<p><img src="/assets/images/2023/07/2023-07-31/07.png" alt="포트포워딩을 통한 원격연결" /></p>

<p>접속되는 것을 확인할 수 있다. 이주소는 외부 주소이므로 이 주소를 활용하면 외부에서도 우리집 네트워크에 접속하는게 가능하다.</p>

<h3 id="과연-이걸로-끝난걸까">과연 이걸로 끝난걸까..?</h3>

<p>외부에서 접속할수 있지만 이방법은 몇가지 문제가 있다. 우선</p>

<ol>
  <li>어색한 ip주소를 외우고 있어야 한다.</li>
  <li>이게 가장 큰 문제인대 일반 가정에서 사용하는 외부 ip는 계속 변경된다. ip는 한정적이기 때문에 인터넷 서비스업체(LG,KT,SK)에서는 할당되는 외부 IP를 수시로 갱신시키면서 미사용중인 ip를 정리하는등 ip가 불필요하게 낭비되지 않게한다.</li>
  <li>이때문에 나도 모르는 사이에 외부ip주소가 변경될 수 있고 그러면 역시 접속되던 것이 어느 순간 다시 안될 수 있다. 이경우 다시 외부ip를 확인하고 변경된 외부ip를 이용하는 수밖에 없다..</li>
</ol>

<p>회사같은 경우 외부ip를 인터넷 서비스 업체에 돈을 주고 계속 해서 고정시키기도 하지만 일반 가정에서 그럴수는 없기때문에 이를 보완할 방법이 필요하다.</p>

<h2 id="ddns">DDNS</h2>

<p>우리가 naver나 daum을 이용할 때 http://www.naver.com을 치고 들어가지 http://223.130.195.95를 치고 사이트에 접속하지는 않는다 이는 “naver.com” 이라는 문자열을 ip주소로 매칭시켜주기 때문인데 여기서 naver.com 을 도메인 이라고 하고 도메인을 ip로 변경해주는 곳을 도메인 네임 서버 라고 한다.</p>

<p><img class="plantuml" src="http://www.plantuml.com/plantuml/svg/~h407374617274756d6c0a407374617274756d6c0a21696e636c756465203c6f66666963652f436f6d6d756e69636174696f6e732f736d735f676174657761793e0a21696e636c756465203c6f66666963652f436f6d6d756e69636174696f6e732f736d74705f636f6e6e6563746f723e0a21696e636c756465203c6f66666963652f436f6d6d756e69636174696f6e732f766f69705f676174657761793e0a21696e636c756465203c6f66666963652f446576696365732f6d6f64656d3e0a21696e636c756465203c6f66666963652f446576696365732f776f726b73746174696f6e3e0a21696e636c756465203c6f66666963652f446576696365732f63656c6c5f70686f6e655f67656e657269633e0a21696e636c756465203c6f66666963652f446576696365732f6465766963655f6c6170746f703e0a0a6167656e7420223c24776f726b73746174696f6e3e5c6eecbbb4ed93a8ed84b02220617320636f6d310a636c6f756420696e7465726e65740a6167656e7420223c24776f726b73746174696f6e3e5c6e44444e53222061732064646e730a6167656e7420223c24776f726b73746174696f6e3e5c6e4e617665725c6e49503a3232332e3133302e3139352e393522206173204e617665720a0a636f6d31202d722d3e20696e7465726e6574203a206e617665722e636f6d20eca091ec868d0a696e7465726e6574202d722d3e2064646e73203a206e617665722e636f6d20ec9d9820697020eca1b0ed9a8c0a64646e73202d642d3e204e61766572203a203232332e3133302e3139352e393520eba19c20eca091ec868d20ed9598eb8f84eba19d20ecb298eba6ac0a4e61766572203c2d3e20636f6d31203a20ed86b5ec8ba00a0a6e6f7465206c656674206f66204e617665720a2020ec9b90eb9e98204e61766572ec998020ecbbb4ed93a8ed84b0ec9d9820ed86b5ec8ba0ec9d800a2020696e7465726e6574ec9d8420eab1b0ecb29820ec9db4eba484eca780eca780eba78c0a2020ed8eb8ec9d98ec838120eca781eca09120ec97b0eab2b0eba38c20ed919ced9884ed9688eb8ba42e0a656e64206e6f74650a0a40656e64756d6c0a40656e64756d6c" /></p>

<h3 id="공유기-제조사에도-ddns-기능을-제공하는-곳이-있다">공유기 제조사에도 ddns 기능을 제공하는 곳이 있다.</h3>

<p>iptime, tplink등 커다란 공유기 회사는 자체 ddns기능을 지원한다. 이말인 즉슨 내 공유기의 도메인을 등록해 놓으면 네이버, 다음 처럼 도메인으로 우리집 네트워크에 접속할 수 있다는 것이고 ip가 변경되더라도 공유기 회사의 ddns기능을 통해 변경된 ip로 도메인이 자동으로 갱신되기 때문에 ip가 변경되는것에 대해 걱정하지 않아도 된다는 것이다(만세!)</p>

<h3 id="공유기-ddns-세팅">공유기 ddns 세팅</h3>

<p>포트 포워딩과 마찬가지로 ddns세팅은 공유기 설정 패이지에서 할 수 있다. iptime기준 [특수기능]의 [DDNS 설정]에서 내 공유기의 도메인을 할당 받을 수 있다. 필자는 이미 등록했기 때문에 스크린 샷처럼 나오지만 DDNS등록 버튼을 통해 자신의 도메인을 세팅할 수 있다. 참고로 iptime의 경우 도메인 주소가 [호스트이름].iptime.org 으로 고정되니 참고할것.</p>

<p><img src="/assets/images/2023/07/2023-07-31/08.png" alt="공유기 DDNS세팅" /></p>

<h3 id="ddns-세팅은-공유기별로-저장된다">ddns 세팅은 공유기별로 저장된다</h3>

<p>ddns 세팅은 공유기 별로 설정된다. 그렇기 때문에 공유기를 변경하는 경우 기존 공유기에서 사용하던 도메인 제거 후 변경된 공유기에 ddns세팅을 해야한다. 참고</p>

<h3 id="도메인으로-접속해보자">도메인으로 접속해보자</h3>

<p>이제 도메인으로 장비에 접속해보자. 도메인을 설정했을므로 이제 ip대신 도메인 이름을 넣고 원격으로 붙어보자.</p>

<p><img src="/assets/images/2023/07/2023-07-31/09.png" alt="도메인을 이용한 접속" /></p>

<p>접속이 잘 되는 것을 확인할 수 있다. 이제 포트포워딩과 DDNS기능을 통해 외부에서도 우리집 홈 네트워크에 접속할 수 있을것이다.</p>]]></content><author><name>Seo Sang Hyok</name></author><category term="network" /><category term="network" /><category term="공유기" /><summary type="html"><![CDATA[네트워크나 서버 프로그래밍, DB공부, 개인 파일서버나 원격접속등 외부에서 내 컴퓨터에 접근해야 할일은 상당히 많다. 만약 우리집에 있는 로컬컴퓨터에 원격 데스크탑이 가능하도록 세팅했다고 하자. 그리고 까패나 다른 곳에서 일이 생겨 내 컴퓨터에 원격으로 붙어야 할때 어떻게 하면 될까?]]></summary></entry><entry><title type="html">MS-SQL 외부 접속 세팅</title><link href="/db/2023/07/30/MSSQL_%EC%99%B8%EB%B6%80%EC%A0%91%EC%86%8D_%EC%84%B8%ED%8C%85.html" rel="alternate" type="text/html" title="MS-SQL 외부 접속 세팅" /><published>2023-07-30T00:00:00+00:00</published><updated>2023-07-30T00:00:00+00:00</updated><id>/db/2023/07/30/MSSQL_%EC%99%B8%EB%B6%80%EC%A0%91%EC%86%8D_%EC%84%B8%ED%8C%85</id><content type="html" xml:base="/db/2023/07/30/MSSQL_%EC%99%B8%EB%B6%80%EC%A0%91%EC%86%8D_%EC%84%B8%ED%8C%85.html"><![CDATA[<h2 id="ms-sql-외부-접속-세팅">MS-SQL 외부 접속 세팅</h2>

<p>스터디를 위해 MS-SQL 을 설치하면 대부분 SQL을 설치한 컴퓨터에서만 작업을 한다. 하지만 다른 컴퓨터에서도 접속할 수 있도록 하려면 어떻게 해야할까?</p>

<p>##</p>]]></content><author><name>Seo Sang Hyok</name></author><category term="DB" /><category term="DB" /><category term="MS-SQL" /><summary type="html"><![CDATA[MS-SQL 외부 접속 세팅]]></summary></entry><entry><title type="html">std::function_VS_함수포인터</title><link href="/c++/2023/07/26/std-function_VS_%ED%95%A8%EC%88%98%ED%8F%AC%EC%9D%B8%ED%84%B0.html" rel="alternate" type="text/html" title="std::function_VS_함수포인터" /><published>2023-07-26T00:00:00+00:00</published><updated>2023-07-26T00:00:00+00:00</updated><id>/c++/2023/07/26/std::function_VS_%ED%95%A8%EC%88%98%ED%8F%AC%EC%9D%B8%ED%84%B0</id><content type="html" xml:base="/c++/2023/07/26/std-function_VS_%ED%95%A8%EC%88%98%ED%8F%AC%EC%9D%B8%ED%84%B0.html"><![CDATA[<p>c++11 부터 함수포인터를 대신할 수 있는 std::function 라이브러리가 추가됐다. 형변환이 명확해야 하는 함수포인터와 다르게 형식만 맞으면 유연하게 사용가능하고 std::bind 와 형행하면 인자처리도 유연하게 할 수 있다. 함수포인터도 많은곳에서 쓰이는 만큼 둘의 사용법을 모두 비교해본다.</p>

<h2 id="기본-사용">기본 사용</h2>

<h3 id="함수-포인터">함수 포인터</h3>

<p>함수포인터의 선언은 아래와 같다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[반환형](*[변수명])([전달인자 형식들..])
</code></pre></div></div>

<p>만날 저렇게 선언하면 많이 블편한데 이경우 typedef를 사용하면 편하다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef [반환형](*[typedef명])([전달인자 형식들..])
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">TestFunc</span><span class="p">(</span><span class="kt">double</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">param</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">param</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">TestFunc2</span><span class="p">(</span><span class="kt">double</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">param</span><span class="o">*</span><span class="mi">10</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">param</span><span class="o">*</span><span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 함수포인터의 선언</span>
    <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">double</span><span class="p">)</span> <span class="o">=</span> <span class="n">TestFunc</span><span class="p">;</span>
    <span class="n">fp</span><span class="p">(</span><span class="mf">100.0</span><span class="p">);</span>

    <span class="c1">// typedef 형식으로 함수포인터 형식 선언</span>
    <span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp_type</span><span class="p">)(</span><span class="kt">double</span><span class="p">);</span>
    <span class="n">fp_type</span> <span class="n">fp2</span> <span class="o">=</span> <span class="n">TestFunc</span><span class="p">;</span>
    <span class="n">fp2</span><span class="p">(</span><span class="mf">200.0</span><span class="p">);</span>

    <span class="n">fp2</span> <span class="o">=</span> <span class="n">TestFunc2</span><span class="p">;</span>
    <span class="n">fp2</span><span class="p">(</span><span class="mf">300.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="stdfunction">std::function</h3>

<p>위와같은 상황에서 function 클래스는 아래와 같이 선언할 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::function&lt;[반환형]([인자형식 리스트])&gt; [변수명] = [대상함수]
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="c1">  // std::function을 사용하기 위해 필요</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">stdFunc</span> <span class="o">=</span> <span class="n">TestFunc</span><span class="p">;</span>
    <span class="n">stdFunc</span><span class="p">(</span><span class="mf">100.0</span><span class="p">);</span>

    <span class="n">stdFunc</span> <span class="o">=</span> <span class="n">TestFunc2</span><span class="p">;</span>
    <span class="n">stdFunc</span><span class="p">(</span><span class="mf">200.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>std::function이 함수포인터보다 좀더 깔끔하고 사용하기 쉬운것을 볼 수 있다.</p>

<h2 id="콜링-컨벤션-처리">콜링 컨벤션 처리</h2>

<p>c++의 콜링 컨벤션은 기본적으로 __cdecl 이지만 윈도우 기준 스레드 함수는 __stdcall 이다. 콜링 컨벤션을 처리하기 위해 함수포인터는 컨벤션을 명확하게 해야 하지만 std::function은 호환처리 가능하다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">TestFunc</span><span class="p">(</span><span class="kt">double</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">param</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">param</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="kr">__stdcall</span> <span class="nf">TestFunc2</span><span class="p">(</span><span class="kt">double</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">param</span><span class="o">*</span><span class="mi">10</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">param</span><span class="o">*</span><span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 함수포인터 타입과 std::function 객체 생성</span>
    <span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">cdclFpType</span><span class="p">)(</span><span class="kt">double</span><span class="p">);</span>           <span class="c1">// 콜링 컨밴션을 명시하지 않으면 기본적으로 __cdecl 콜링 컨벤션을 따른다.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">stdFunc</span><span class="p">;</span>
    
    <span class="n">cdclFpType</span> <span class="n">cdclFp</span> <span class="o">=</span> <span class="n">TestFunc</span><span class="p">;</span>               <span class="c1">// 가능</span>
    <span class="n">stdFunc</span> <span class="o">=</span>  <span class="n">TestFunc</span><span class="p">;</span>                        <span class="c1">// 역시 가능</span>

    <span class="n">cdclFp</span> <span class="o">=</span> <span class="n">TestFunc2</span><span class="p">;</span>                         <span class="c1">// 에러!! TestFunc2의 콜링 컨벤션은 __stdcall이다</span>

    <span class="c1">// 아래처럼 __stdcall 콜링컨벤션을 사용하는 함수포인터 타입을 만들어야 대입가능</span>
    <span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="kr">__stdcall</span><span class="o">*</span><span class="n">stdcallFpType</span><span class="p">)(</span><span class="kt">double</span><span class="p">);</span> 
    <span class="n">stdcallFpType</span> <span class="n">stdcallFp</span> <span class="o">=</span> <span class="n">TestFunc2</span>

    <span class="n">stdFunc</span> <span class="o">=</span> <span class="n">TestFunc2</span><span class="p">;</span>                        <span class="c1">// 가능!! std::function은 콜링컨벤션 호환된다.</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="클래스-맴버함수-처리">클래스 맴버함수 처리</h2>

<p>클래스 맴버함수의 함수포인터의 경우 호출하고자 하는 대상 즉 <strong>어떤 인스턴스의 함수를 호출했느냐??</strong> 가 중요하다. 일반함수의 경우 전역 범위를 가지지만 클래스의 경우 <strong>인스턴스</strong>가 생성되고 각 인스턴스의 맴버함수가 호출되기 때문이다.</p>

<h3 id="함수포인터">함수포인터</h3>

<p>함수포인터로 클래스 맴버함수를 표현하고 사용하는 방법은 아래와 같다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CTestClass</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">CTestClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">initVal</span><span class="p">){</span><span class="n">m_val</span> <span class="o">=</span> <span class="n">initVal</span><span class="p">;}</span>
    <span class="o">~</span><span class="n">CTestClass</span><span class="p">(){;}</span>
    <span class="kt">int</span> <span class="nf">testFunc</span><span class="p">(){</span> <span class="k">return</span> <span class="n">m_val</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">testFunc2</span><span class="p">(){</span> <span class="k">return</span> <span class="n">m_val</span><span class="o">*</span><span class="mi">10</span><span class="p">;</span> <span class="p">}</span>    

    <span class="kt">int</span> <span class="n">testFunc3</span><span class="p">()</span> <span class="k">const</span> 
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_val</span><span class="o">*</span><span class="mi">100</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">m_val</span><span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 아래와 같이 클래스 맴버 함수 포인터 선언 가능</span>
    <span class="kt">int</span><span class="p">(</span><span class="n">CTestClass</span><span class="o">::*</span><span class="n">pCfp</span><span class="p">)()</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">CTestClass</span><span class="o">::</span><span class="n">testFunc</span><span class="p">;</span>

    <span class="c1">// 타입정의도 가능</span>
    <span class="k">typedef</span> <span class="kt">int</span><span class="p">(</span><span class="n">CTestClass</span><span class="o">::*</span><span class="n">ClassfpType</span><span class="p">)();</span>
    <span class="n">ClassfpType</span> <span class="n">pCfp2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">CTestClass</span><span class="o">::</span><span class="n">testFunc2</span><span class="p">;</span>

    <span class="c1">// 여기까진 맴버 함수만 정의했을 뿐 대상 인스턴스가 없으므로 사용하 려면 인스턴스 생성먼저..</span>
    <span class="n">CTestClass</span> <span class="n">a</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="n">CTestClass</span> <span class="n">b</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

    <span class="c1">// 사용하고자 하는 클래스 맴버 함수 포인터를 인스턴스와 함께 사용한다. 연산자 우선 순위가 있어 괄호로 묶어서 사용</span>
    <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="o">*</span><span class="n">pCfp</span><span class="p">)();</span>    <span class="c1">// 100</span>
    <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="o">*</span><span class="n">pCfp2</span><span class="p">)();</span>   <span class="c1">// 1000</span>
    <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="o">*</span><span class="n">pCfp</span><span class="p">)();</span>    <span class="c1">// 200</span>
    <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="o">*</span><span class="n">pCfp2</span><span class="p">)();</span>   <span class="c1">// 2000</span>
<span class="p">}</span>
</code></pre></div></div>
<p>위와 같이 클래스 맴버함수의 함수포인터를 호출할 경우 대상 인스턴스를 명확히 해야 한다.</p>

<h3 id="stdfunction-1">std::function</h3>

<p>std::function도 마찬가지로 사용하고자 하는 맴버를 명시해야 한다. 다만 함수포인터와 다르게 내부적으로 <strong>호출한 객체의 래퍼런스를 넘겨준다</strong>(this 포인터를 생각하면 되겠다)</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 클래스 맴버 함수 포인터 선언 및 할당.</span>
<span class="c1">// function 객체 생성 시 인자로 CTestClass의 레퍼런스를 넘기는것에 주목하자</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">CTestClass</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ClassFunc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">CTestClass</span><span class="o">::</span><span class="n">testFunc1</span><span class="p">;</span>

<span class="c1">// 클래스 인스턴스 생성</span>
<span class="n">CTestClass</span> <span class="nf">a</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="n">CTestClass</span> <span class="nf">b</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

<span class="n">ClassFunc</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>   <span class="c1">// a.testFunc1() 과 같음</span>
<span class="n">ClassFunc</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>   <span class="c1">// b.testFunc1() 과 같음</span>

<span class="n">ClassFunc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">CTestClass</span><span class="o">::</span><span class="n">testFunc2</span><span class="p">;</span>
<span class="n">ClassFunc</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>   <span class="c1">// a.testFunc2() 와 같음</span>
<span class="n">ClassFunc</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>   <span class="c1">// b.testFunc2() 와 같음</span>
</code></pre></div></div>

<h2 id="const-맴버-함수-처리">const 맴버 함수 처리</h2>

<p>위 예제에서 CTestClass::testFunc3 은 const 함수다. 그렇기 때문에 위에서 선언한 함수포인터나 function 객체를 사용하면 에러가 난다.(상수 함수를 비상수 함수 포인터(function객체)에 할당하려 했으니까..)</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">int</span><span class="p">(</span><span class="n">CTestClass</span><span class="o">::*</span><span class="n">ClassfpType</span><span class="p">)();</span>
<span class="n">ClassfpType</span> <span class="n">pCfp2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">CTestClass</span><span class="o">::</span><span class="n">testFunc2</span><span class="p">;</span>     <span class="c1">// 이것은 가능하지만..</span>
<span class="n">pCfp2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">CTestClass</span><span class="o">::</span><span class="n">testFunc3</span><span class="p">;</span>                 <span class="c1">// 이것은 에러다. testFunc3이 const(상수) 함수이므로..</span>

<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">CTestClass</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ClassFunc</span><span class="p">;</span>
<span class="n">ClassFunc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">CTestClass</span><span class="o">::</span><span class="n">testFunc3</span><span class="p">;</span>             <span class="c1">// 같은 이유로 이것도 에러</span>
</code></pre></div></div>

<p>const 함수는 const 인스턴스에서만 호출 가능하므로 아래처럼 선언해서 사용해야 한다.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">int</span><span class="p">(</span><span class="k">const</span> <span class="n">CTestClass</span><span class="o">::*</span><span class="n">ConstClassfpType</span><span class="p">)();</span>
<span class="n">ConstClassfpType</span> <span class="n">pCfp3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">CTestClass</span><span class="o">::</span><span class="n">testFunc3</span><span class="p">;</span> <span class="c1">// OK</span>

<span class="k">const</span> <span class="n">CTestClass</span> <span class="nf">c</span><span class="p">(</span><span class="mi">400</span><span class="p">);</span>
<span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="o">*</span><span class="n">pCfp3</span><span class="p">)();</span>                                    <span class="c1">// 40000</span>


<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="k">const</span> <span class="n">CTestClass</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ClassFunc2</span><span class="p">;</span> <span class="c1">// function 객체도 const 객체의 레퍼런스를 받도록 하면..</span>
<span class="n">ClassFunc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">CTestClass</span><span class="o">::</span><span class="n">testFunc3</span><span class="p">;</span>              <span class="c1">// OK</span>
<span class="n">ClassFunc2</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>                                   <span class="c1">// 호출 가능~</span>
</code></pre></div></div>

<p>테스트 해보니 vs2022 기준 std::function의 경우 const 함수를 받을 수 있었다. 하지만 일관성을 위해 const는 const를 받는 function을 이용하는걸 권한다.</p>

<h2 id="함수포인터---stdfunction-간-대입--변환">함수포인터 &lt;-&gt; std::function 간 대입 / 변환</h2>

<p>저장하는 함수 형식만 맞다면 함수포인터와 std::fucntion은 서로간에 대입(변환)이 가능하다.</p>

<h3 id="stdfunction---함수포인터-대입">std::function &lt;- 함수포인터 대입</h3>

<p>std::function에 함수포인터를 매칭하는건 크게 어렵지 않다. 그냥 대입하면 끝</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">TestFunc</span><span class="p">(</span><span class="kt">double</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">param</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">param</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 함수포인터의 선언</span>
    <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">double</span><span class="p">)</span> <span class="o">=</span> <span class="n">TestFunc</span><span class="p">;</span>

    <span class="c1">// std::function 선언</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">doulbe</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">stdFunction</span><span class="p">;</span>

    <span class="c1">// std::function 에 함수포인터 대입</span>
    <span class="n">stdFunction</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>

    <span class="n">stdFunction</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>    <span class="c1">// 100</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="stdfunction-을-함수포인터로-변환">std::function 을 함수포인터로 변환</h3>

<p>std::function 을 함수포인터로 변환하기 위해선 std::function::target() 함수를 이용한다. 해당 함수는 std::function이 저장하고 있는 <strong>함수포인터의 포인터</strong> 를 반환 하므로 이 함수를 이용해서 std::function에 저장된 함수포인터를 가져올 수 있다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
     <span class="c1">// std::function 선언</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">doulbe</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">stdFunction</span> <span class="o">=</span> <span class="n">TestFunc</span><span class="p">;</span>

    <span class="c1">// std::function에 매핑된 함수 포인터의 포인터를 가져온다.</span>
    <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="kt">double</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">stdFunction</span><span class="p">.</span><span class="n">target</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">();</span>    <span class="c1">// 함수 포인터의 포인터 이브로 * 를 붙여 함수포인터로 변경</span>

    <span class="c1">//아래와 같이 사용</span>
    <span class="n">pf</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

    <span class="c1">// 사용이 불편하면 아래처럼 하는것도 ok</span>
    <span class="k">auto</span> <span class="n">pf2</span> <span class="o">=</span> <span class="o">*</span><span class="n">stdFunction</span><span class="p">.</span><span class="n">target</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">pf2</span><span class="p">(</span><span class="mi">300</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>std::function::target 함수는 템플릿 이 필요한 맴버함수이기 때문에 가져올 함수형을 명시해서 사용해야만 한다. 윈도우 스래드 함수의 경우 아래와 같은 함수 포인터를 받아온다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="n">WINAPI</span> <span class="p">(</span><span class="o">*</span><span class="n">ThreadStartRoutine</span><span class="p">)(</span><span class="n">LPVOID</span> <span class="n">param</span><span class="p">)</span>
</code></pre></div></div>

<p>그렇기 때문에 std::function을 사용하는 경우 스래드 함수로 변환이 필요할 때 사용할 수 있을것이다. std::thread 를 이용할 수도 있는데 해당 클래스는 나중에 따로 블로깅 할 예정이다.</p>

<h4 id="stdfunction-에-함수가-매핑되었는지-확인하는-방법">std::function 에 함수가 매핑되었는지 확인하는 방법</h4>

<p>함수포인터는 nullptr을 넣어 함수 매핑여부를 확인 할 수 있다. std::function 의 경우 target() 맴버 함수를 이용해서 널체크를 할 수도 있겠지만 매번 함수 타입을 치려면 불편하다. 이때문에 함수가 매핑되어 있는지 여부는 std::function::operator bool() 을 이용해서 매핑여부를 확인할 수 있다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
     <span class="c1">// std::function 선언</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">doulbe</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">stdFunction</span><span class="p">;</span>  <span class="c1">// 아직 아무것도 매핑되어 있지 않다.</span>

    <span class="kt">bool</span> <span class="n">functionIsEmpty</span> <span class="o">=</span> <span class="n">stdFunction</span><span class="p">;</span>      <span class="c1">// true</span>

    <span class="n">stdFunction</span> <span class="o">=</span> <span class="n">TestFunc</span><span class="p">;</span>

    <span class="n">functionIsEmpty</span> <span class="o">=</span> <span class="n">stdFunction</span><span class="p">;</span>           <span class="c1">// false</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>]]></content><author><name>Seo Sang Hyok</name></author><category term="c++" /><category term="c++" /><category term="thread" /><summary type="html"><![CDATA[c++11 부터 함수포인터를 대신할 수 있는 std::function 라이브러리가 추가됐다. 형변환이 명확해야 하는 함수포인터와 다르게 형식만 맞으면 유연하게 사용가능하고 std::bind 와 형행하면 인자처리도 유연하게 할 수 있다. 함수포인터도 많은곳에서 쓰이는 만큼 둘의 사용법을 모두 비교해본다.]]></summary></entry><entry><title type="html">스레드 생성 및 사용</title><link href="/c++/2023/07/21/%EC%8A%A4%EB%A0%88%EB%93%9C%EC%83%9D%EC%84%B1%EB%B0%8F%EC%82%AC%EC%9A%A9.html" rel="alternate" type="text/html" title="스레드 생성 및 사용" /><published>2023-07-21T00:00:00+00:00</published><updated>2023-07-21T00:00:00+00:00</updated><id>/c++/2023/07/21/%EC%8A%A4%EB%A0%88%EB%93%9C%EC%83%9D%EC%84%B1%EB%B0%8F%EC%82%AC%EC%9A%A9</id><content type="html" xml:base="/c++/2023/07/21/%EC%8A%A4%EB%A0%88%EB%93%9C%EC%83%9D%EC%84%B1%EB%B0%8F%EC%82%AC%EC%9A%A9.html"><![CDATA[<h2 id="스레드-생성-및-사용">스레드 생성 및 사용</h2>

<p>멀티 스레드를 위해 스래드 사용법을 기술한다.</p>

<h3 id="스래드-생성">스래드 생성</h3>

<p>스래드 생성은 <strong>CreateThread()</strong>, <strong>_beginthreadex()</strong>, <del>_beginthread()</del> 로 생성할 수 있다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// CreateThread</span>
<span class="n">HANDLE</span> <span class="n">WINAPI</span> <span class="nf">CreateThread</span><span class="p">(</span>
    <span class="n">_In_opt_</span> <span class="n">LPSECURITY_ATTRIBUTES</span> <span class="n">lpThreadAttributes</span><span class="p">,</span>
    <span class="n">_In_</span> <span class="n">SIZE_T</span> <span class="n">dwStackSize</span><span class="p">,</span>
    <span class="n">_In_</span> <span class="n">LPTHREAD_START_ROUTINE</span> <span class="n">lpStartAddress</span><span class="p">,</span>
    <span class="n">_In_opt_</span> <span class="n">LPVOID</span> <span class="n">lpParameter</span><span class="p">,</span>
    <span class="n">_In_</span> <span class="n">DWORD</span> <span class="n">dwCreationFlags</span><span class="p">,</span>
    <span class="n">_Out_opt_</span> <span class="n">LPDWORD</span> <span class="n">lpThreadId</span>
<span class="p">);</span>

<span class="c1">// _beginthreadex</span>
<span class="n">_ACRTIMP</span> <span class="kt">uintptr_t</span> <span class="kr">__cdecl</span> <span class="nf">_beginthreadex</span><span class="p">(</span>
    <span class="n">_In_opt_</span>  <span class="kt">void</span><span class="o">*</span>                    <span class="n">_Security</span><span class="p">,</span>
    <span class="n">_In_</span>      <span class="kt">unsigned</span>                 <span class="n">_StackSize</span><span class="p">,</span>
    <span class="n">_In_</span>      <span class="n">_beginthreadex_proc_type</span> <span class="n">_StartAddress</span><span class="p">,</span>
    <span class="n">_In_opt_</span>  <span class="kt">void</span><span class="o">*</span>                    <span class="n">_ArgList</span><span class="p">,</span>
    <span class="n">_In_</span>      <span class="kt">unsigned</span>                 <span class="n">_InitFlag</span><span class="p">,</span>
    <span class="n">_Out_opt_</span> <span class="kt">unsigned</span><span class="o">*</span>                <span class="n">_ThrdAddr</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="_beginthread-는-사용하지-말자">_beginthread() 는 사용하지 말자.</h3>

<p>_beginthread()함수는 스래드 생성 후 스래드를 컨트롤 할수 없으며 보안문제도 있다. 걍 없는 함수다 생각하고 사용하지 말것.</p>

<h3 id="사용-예">사용 예</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="n">WINAPI</span> <span class="nf">ThreadFunction</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">Sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
    <span class="p">}</span>    

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">hThreadHandle</span><span class="p">{</span><span class="n">INVALID_HANDLE_VALUE</span><span class="p">};</span>
    <span class="n">DWORD</span> <span class="n">dwThreadID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"This is Thread Func"</span>

    <span class="n">hThreadHandle</span> <span class="o">=</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="o">::</span><span class="n">_beginthreadex</span><span class="p">(</span>
        <span class="nb">nullptr</span><span class="p">,</span>    <span class="c1">// 1. 보안속성 -&gt; null을 주면 부모 프로세스의 보안 속성을 가져간다.</span>
        <span class="mi">0</span><span class="p">,</span>          <span class="c1">// 2. 스래드 스텍 사이즈 0으로 하면 일반적으로 1MB</span>
        <span class="n">ThreadFunction</span><span class="p">,</span> <span class="c1">// 3. 수행할 함수</span>
        <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">str</span><span class="p">,</span>    <span class="c1">// 4. 인자</span>
        <span class="mi">0</span><span class="p">,</span>              <span class="c1">// 5. 생성 플레그</span>
        <span class="o">&amp;</span><span class="n">dwThreadID</span>     <span class="c1">// 생성 된 스래드 ID</span>
    <span class="p">);</span>

    <span class="cm">/* 
    혹은
    hThreadHandle = (HANDLE)::CreateThread(
    nullptr, 
    0, 
    ThreadFunction, (LPVOID)str,
    0, 
    &amp;dwThreadID
    );
    */</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h4 id="인자들의-설명">인자들의 설명</h4>

<h5 id="1-보안-속성">1. 보안 속성</h5>

<p>보안속성은 일반적으로 NULL(nullptr)을 넣어준다. 이럴경우 호출한 프로세스의 보안 속성을 따라간다.</p>

<h5 id="2-스레드-스텍-사이즈">2. 스레드 스텍 사이즈</h5>

<p>스래드도 호출되는 함수의 성질을 띄기 때문에 내부적으로 스텍이 잡힌다. 0을 주면 기본적으로 1MB의 스택 사이즈가 잡힌다. 다른 값으로 넣으면 해당 크기만큰 스택이 잡힌다.</p>

<h5 id="3-스레드-함수">3. 스레드 함수</h5>

<p>수행할 스래드 함수가 호출된다. winapi 상으로 호출되는 스레드 함수는 아래의 형식이다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">unsigned</span> <span class="p">(</span><span class="kr">__stdcall</span><span class="o">*</span> <span class="n">_beginthreadex_proc_type</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</code></pre></div></div>

<p>일반적으로 c/c++의 호출규약은 __cdecl 형식인데 스레드 함수는 __stdcall 형식이다. 둘의 차이는 함수 내부 스택을 호출한쪽(caller)에서 정리하느냐(<strong>__cdecl</strong>) 호출을 당한쪽(callee). 즉 스래드 함수에서 정리하느냐(<strong>__stdcall</strong>)의 차이가 있다. 아마도 스레드의 경우 종료시점이 명확하지 않기때문에 피호출쪽에서 스텍을 정리하는게 아닐까 하는 생각을 한다.(찾아보면 둘의 차이가 없다고 하는 사람들도 있다..)</p>

<h5 id="4-전달인자">4. 전달인자</h5>

<p>전달인자는 void<em>형식으로 전달한다. 만약 다수의 인자가 필요하면 구조체를 하나 선언해서 전달하면 될것이다. void</em>형으로 전달되니 사용하고자 하는 형으로 케스팅 후 사용한다.</p>

<h5 id="5-생성-플래그">5. 생성 플래그</h5>

<p>0으로 주면 호출즉시 스래드 함수가 수행된다. 만약 <strong>CREATE_SUSPENDED</strong> 옵션으로 생성하면 스래드는 일시정지(suspended) 상태로 생성된다. 이경우 ResumeThread() 함수로 직접 스래드를 작동 시켜야 한다.</p>

<hr />

<h3 id="createthread-vs-_beginthreadex">CreateThread VS _beginthreadex</h3>

<p>두함수는 TLS처리 이외엔 같은 함수라고 보면 된다. strtok함수와 같이 내부적으로 정적(static)영역을 사용하는 함수의 경우 같은 함수를 동시에 여러 스레드에서 호출하면 동기화 문제가 발생할 수 있는데 _beginthreadex 의 경우 내부적으로 TLS를 생성해서 사용하기 때문에 이런 문제가 발생하지 않는다. 그러니 속편히 윈도우계열에선  _beginthreadex 를 사용하자 하는게 나을수도 있을듯 하다.</p>

<h3 id="간략한-스레드-클래스">간략한 스레드 클래스</h3>

<p>위 기능을 지원하는 스레드 클래스를 만들어 보았다. 스래드를 활용하고자 하는 경우 아래 클래스를 상속받아 ThreadFunc()를 제정의 해서 사용하면 된다. 보완할점이 있을수도 있겠지만 도움이 될까 해서 공유한다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// Thread.h</span>
<span class="k">class</span> <span class="nc">CThread</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">CThread</span><span class="p">();</span>
    <span class="o">~</span><span class="n">CThread</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">ThreadFunc</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">Start</span><span class="p">(</span><span class="kt">bool</span> <span class="n">StartImmediate</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">Join</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">waitMilisec</span> <span class="o">=</span> <span class="n">INFINITE</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">Suspend</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">Resume</span><span class="p">();</span>

    <span class="n">HANDLE</span> <span class="n">GetThreadHandle</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hThreadHandle</span><span class="p">;</span> <span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="k">static</span> <span class="kt">unsigned</span> <span class="n">WINAPI</span> <span class="nf">ThreadStartRoutine</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">param</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">HANDLE</span> <span class="n">hThreadHandle</span><span class="p">{</span> <span class="n">INVALID_HANDLE_VALUE</span> <span class="p">};</span>
    <span class="n">UINT</span> <span class="n">uiThreadID</span><span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="kt">bool</span> <span class="n">bJobEnded</span><span class="p">{</span> <span class="nb">true</span> <span class="p">};</span>
<span class="p">};</span>

<span class="c1">// Thread.cpp</span>
<span class="n">CThread</span><span class="o">::</span><span class="n">CThread</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">hThreadHandle</span> <span class="o">=</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">CThread</span><span class="o">::~</span><span class="n">CThread</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hThreadHandle</span> <span class="o">!=</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hThreadHandle</span><span class="p">);</span>
    <span class="p">}</span>
            
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="n">WINAPI</span> <span class="n">CThread</span><span class="o">::</span><span class="n">ThreadStartRoutine</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CThread</span><span class="o">*</span> <span class="n">pThread</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">CThread</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pThread</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pThread</span><span class="o">-&gt;</span><span class="n">ThreadFunc</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">CThread</span><span class="o">::</span><span class="n">Start</span><span class="p">(</span><span class="kt">bool</span> <span class="n">StartImmediate</span><span class="cm">/* = true*/</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">dwCreateFlag</span> <span class="o">=</span> <span class="n">StartImmediate</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">CREATE_SUSPENDED</span><span class="p">;</span>

    <span class="n">hThreadHandle</span> <span class="o">=</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="o">::</span><span class="n">_beginthreadex</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CThread</span><span class="o">::</span><span class="n">ThreadStartRoutine</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">dwCreateFlag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiThreadID</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">CThread</span><span class="o">::</span><span class="n">Join</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">waitMilisec</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hThreadHandle</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">hThreadHandle</span><span class="p">,</span> <span class="n">waitMilisec</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">CThread</span><span class="o">::</span><span class="n">Suspend</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hThreadHandle</span> <span class="o">!=</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">::</span><span class="n">SuspendThread</span><span class="p">(</span><span class="n">hThreadHandle</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">CThread</span><span class="o">::</span><span class="n">Resume</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hThreadHandle</span> <span class="o">!=</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">::</span><span class="n">ResumeThread</span><span class="p">(</span><span class="n">hThreadHandle</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="사용-예-1">사용 예</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CTestThread</span> <span class="o">:</span><span class="k">public</span> <span class="n">CThread</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">CTestThread</span><span class="p">()</span> <span class="o">:</span> <span class="n">CThread</span><span class="p">()</span> <span class="p">{;}</span>
	<span class="o">~</span><span class="n">CTestThread</span><span class="p">()</span> <span class="p">{;}</span>

    <span class="c1">// 수행하고자 하는 함수를 제정의해서 사용한다.</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ThreadFunc</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
			<span class="n">Sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello World!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">CTestThread</span> <span class="n">testThread</span><span class="p">;</span>    
	<span class="n">testThread</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
	<span class="n">testThread</span><span class="p">.</span><span class="n">Join</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Seo Sang Hyok</name></author><category term="c++" /><category term="c++" /><category term="thread" /><summary type="html"><![CDATA[스레드 생성 및 사용]]></summary></entry><entry><title type="html">윈도우10 무료사용법</title><link href="/tip/2023/07/16/%EC%9C%88%EB%8F%84%EC%9A%B010_%EB%AC%B4%EB%A3%8C%EC%82%AC%EC%9A%A9.html" rel="alternate" type="text/html" title="윈도우10 무료사용법" /><published>2023-07-16T00:00:00+00:00</published><updated>2023-07-16T00:00:00+00:00</updated><id>/tip/2023/07/16/%EC%9C%88%EB%8F%84%EC%9A%B010_%EB%AC%B4%EB%A3%8C%EC%82%AC%EC%9A%A9</id><content type="html" xml:base="/tip/2023/07/16/%EC%9C%88%EB%8F%84%EC%9A%B010_%EB%AC%B4%EB%A3%8C%EC%82%AC%EC%9A%A9.html"><![CDATA[<h2 id="윈도우10-무료사용법">윈도우10 무료사용법</h2>

<p>가상머신을 설치하는 경우 머신마다 윈도우10을 구입해서 사용하기에는 큰 부담이 있다. 하지만 MS에서 매 반기마다 사용할 수 있는 라이센스를 배포하고 있는대 이를 이용해서 윈도우를 합법적으로 사용할 수 있다.</p>

<h3 id="라이센스는-반기마다-갱신해야-한다">라이센스는 반기마다 갱신해야 한다.</h3>

<p>물론 MS에서 평생사용할 수 있는 라이센스를 배포하진 않는다. 위에도 언급했지만 MS에서 제공하는 라이센스는 반기동안의 유효기간이 있기때문에 반기마다 라이센스가 만료되면 갱신해줘야 한다. 하지만 갱신이 크게 어려운건 아니니 반년에 한번만 수고를 해준다면 윈도우를 무료로 이용하는게 가능하다(합법적으로 말이다!)</p>

<p><img src="/assets/images/2023/07/2023-07-16/01.png" alt="반기용 CD키" />
(어자피 반기(6개월만 사용하면 만료되는 키라 시리얼은 가렸다.))</p>

<p>들어가보면 알겠지만 거의 대부분의 윈도우 버전에대해 반기별 시리얼을 재공하고 있다.</p>

<h3 id="설치과정에-대해-알아보자">설치과정에 대해 알아보자</h3>

<h4 id="인증과정은-커맨드라인으로명령프롬프트-진행된다">인증과정은 커맨드라인으로(명령프롬프트) 진행된다.</h4>

<p>인증처리는 마우스로 설정-시스템 이런대서 처리하는것이 아니라 명령프롬프트 를 <strong>관리자권한</strong> 으로 실행 후 타이핑으로 진행한다.</p>

<h4 id="기존-시리얼-제거">기존 시리얼 제거</h4>

<p>만약 윈도우를 설치할 때 시리얼을 입력하지 않았으면 상관없지만 잘못된 시리얼을 입력해서 설치한 경우 기존의 시리얼을 재거 해야만 한다 커맨드라인(명령프롬프트)를 <strong>관리자권한</strong>으로 실행 후 아래 명령어를 입력하면 기존 제품키를 제거할 수 있다.</p>

<div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">rem 제품키 삭제 </span>
<span class="nb">slmgr</span> <span class="na">/upk

</span><span class="c">rem 제품키를 레지스트리에서 삭제</span>
<span class="nb">slmgr</span> <span class="na">/cpky
</span></code></pre></div></div>

<h4 id="kms-서버설정">KMS 서버설정</h4>

<p>윈도우에서 무료로 제공하는 시리얼이라고해서 그냥 떡! 하니 입력하면 사용할수 있도록 호락호락하게 해놓진 않았다.(MS는 엄연히 이익을 추구하는 기업이다..) 반기용 시리얼을 사용하려면 KMS 서버라는 것을 설정 후 해당 서버에서 반기용 시디키를 인증받는 식으로 처리해야 한다. 명령프롬프트에서 아래 명령어로 해당 서버를 설정 할 수 있다.(무슨말인지 모르겠으면 걍 치자)</p>

<div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">rem KMS 서버 설정</span>
<span class="nb">slmgr</span> <span class="na">/skms </span><span class="kd">kms8</span>.msguides.com
<span class="nb">slmgr</span> <span class="na">/skms </span><span class="kd">kms</span>.digiboy.ir
</code></pre></div></div>

<h4 id="시디키-인증">시디키 인증</h4>

<p>위 과정이 모두 완료됬으면 아래 링크에서 반기사용 시리얼을 가져와서 인증하면 된다. 반기용 시리얼은 아래 링크에서 확인 할 수 있다.</p>

<p><a href="https://learn.microsoft.com/ko-kr/windows-server/get-started/kms-client-activation-keys#generic-volume-license-keys-gvlk">https://learn.microsoft.com/ko-kr/windows-server/get-started/kms-client-activation-keys#generic-volume-license-keys-gvlk</a></p>

<p>시리얼을 확인했으면 아래 명령어로 인증을 진행한다.</p>

<div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">rem 시리얼 인증. 여기선 시리얼이 W269N-WFGWX-YVC9B-4J6C9-T83GX 라고 가정한다.</span>
<span class="nb">slmgr</span> <span class="na">/ipk </span><span class="kd">W269N</span><span class="na">-WFGWX-YVC</span><span class="m">9</span><span class="kd">B</span><span class="o">-</span><span class="m">4</span><span class="kd">J6C9</span><span class="na">-T</span><span class="m">83</span><span class="kd">GX</span>
<span class="nb">slmgr</span> <span class="na">/skms </span><span class="kd">kms8</span>.msguides.com
<span class="nb">slmgr</span> <span class="na">/ato
</span><span class="nb">slmgr</span> <span class="na">/xpr
</span></code></pre></div></div>

<h4 id="여기까지하면-인증-완료">여기까지하면 인증 완료</h4>

<p>위 과정까지 진행하면 정식으로 인증된 것을 볼 수 있다. 반년동안 잘 사용하면 된다.</p>

<h4 id="반년이-지나면">반년이 지나면??</h4>

<p>반년(정확히는 반기)가 지나면 인증기간이 만료되기 때문에 기존 시리얼은 폐기하고 새로운 시리얼로 다시 인증을 진행하면 된다. 기존에 이미 KMS서버세팅은 해놨기때문에 여기서는 기존 시리얼만 폐기후 다시 등록해주면 된다.</p>

<div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">rem 제품키 삭제 </span>
<span class="nb">slmgr</span> <span class="na">/upk

</span><span class="c">rem 제품키를 레지스트리에서 삭제</span>
<span class="nb">slmgr</span> <span class="na">/cpky

</span><span class="c">rem 시리얼을 갱신하는 경우 이미 기존에 KMS서버 세팅을 해놨을것이기 때문에 따로 세팅할 필요는 없다.</span>

<span class="c">rem 시리얼 인증. 여기선 시리얼이 AAAAA-BBBBB-CCCCC-DDDDD-EEEEE 라고 가정한다.</span>
<span class="nb">slmgr</span> <span class="na">/ipk </span><span class="kd">AAAAA</span><span class="na">-BBBBB-CCCCC-DDDDD-EEEEE
</span><span class="nb">slmgr</span> <span class="na">/skms </span><span class="kd">kms8</span>.msguides.com
<span class="nb">slmgr</span> <span class="na">/ato
</span><span class="nb">slmgr</span> <span class="na">/xpr
</span></code></pre></div></div>

<h3 id="주의사항">주의사항</h3>

<p>MS에서 정식으로 제공하는 방법이기때문에 해킹이나 악성코드의 걱정은 할 필요가 없다. 하지만 당연히 개인적으로 사용하는 용도로만 사용할 수 있기때문에 집에서만 사용하고 회사나 다른 업무용 장비에선 <strong>절.대.로.</strong> 사용하지 말것. 괜시리 나중에 보안감사 같은거 걸려서 피볼수도 있다.</p>

<h3 id="위-내용을-한방에-하는-배치파일-정리">위 내용을 한방에 하는 배치파일 정리</h3>

<p>이런저런 내용 길게 써놓긴 했지만 아래 배치로 퉁칠 수 있겠다.</p>

<h4 id="막-윈도우를-설치했을-때즉-kms-세팅이-되지-않았을때">막 윈도우를 설치했을 때(즉 KMS 세팅이 되지 않았을때)</h4>

<div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">rem 제품키 삭제 </span>
<span class="nb">slmgr</span> <span class="na">/upk

</span><span class="c">rem 제품키를 레지스트리에서 삭제</span>
<span class="nb">slmgr</span> <span class="na">/cpky

</span><span class="c">rem KMS 서버 설정</span>
<span class="nb">slmgr</span> <span class="na">/skms </span><span class="kd">kms8</span>.msguides.com
<span class="nb">slmgr</span> <span class="na">/skms </span><span class="kd">kms</span>.digiboy.ir

<span class="c">rem 시리얼 인증. 여기선 시리얼이 AAAAA-BBBBB-CCCCC-DDDDD-EEEEE 라고 가정한다.</span>
<span class="nb">slmgr</span> <span class="na">/ipk </span><span class="kd">AAAAA</span><span class="na">-BBBBB-CCCCC-DDDDD-EEEEE
</span><span class="nb">slmgr</span> <span class="na">/skms </span><span class="kd">kms8</span>.msguides.com
<span class="nb">slmgr</span> <span class="na">/ato
</span><span class="nb">slmgr</span> <span class="na">/xpr
</span></code></pre></div></div>

<h4 id="이후-반기마다-시리얼을-갱신해야할-때">이후 반기마다 시리얼을 갱신해야할 때</h4>

<div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">rem 제품키 삭제 </span>
<span class="nb">slmgr</span> <span class="na">/upk

</span><span class="c">rem 제품키를 레지스트리에서 삭제</span>
<span class="nb">slmgr</span> <span class="na">/cpky

</span><span class="c">rem 시리얼을 갱신하는 경우 이미 기존에 KMS서버 세팅을 해놨을것이기 때문에 따로 세팅할 필요는 없다.</span>

<span class="c">rem 시리얼 인증. 여기선 시리얼이 AAAAA-BBBBB-CCCCC-DDDDD-EEEEE 라고 가정한다.</span>
<span class="nb">slmgr</span> <span class="na">/ipk </span><span class="kd">AAAAA</span><span class="na">-BBBBB-CCCCC-DDDDD-EEEEE
</span><span class="nb">slmgr</span> <span class="na">/skms </span><span class="kd">kms8</span>.msguides.com
<span class="nb">slmgr</span> <span class="na">/ato
</span><span class="nb">slmgr</span> <span class="na">/xpr
</span></code></pre></div></div>

<h3 id="관련-동영상">관련 동영상</h3>

<p>해당 포스트는 아래 동영상을 참고해서 작성했다.
<img src="//https://youtu.be/-sGXpKVwX9w" alt="" /></p>]]></content><author><name>Seo Sang Hyok</name></author><category term="tip" /><category term="windows10" /><summary type="html"><![CDATA[윈도우10 무료사용법]]></summary></entry><entry><title type="html">Plantuml, Mermaid 웹 에디터</title><link href="/uml/2023/07/05/Plantuml_Mermaid_%EC%9B%B9_%EC%97%90%EB%94%94%ED%84%B0.html" rel="alternate" type="text/html" title="Plantuml, Mermaid 웹 에디터" /><published>2023-07-05T00:00:00+00:00</published><updated>2023-07-05T00:00:00+00:00</updated><id>/uml/2023/07/05/Plantuml_Mermaid_%EC%9B%B9_%EC%97%90%EB%94%94%ED%84%B0</id><content type="html" xml:base="/uml/2023/07/05/Plantuml_Mermaid_%EC%9B%B9_%EC%97%90%EB%94%94%ED%84%B0.html"><![CDATA[<h2 id="plantuml-mermaid-웹-에디터">Plantuml, Mermaid 웹 에디터</h2>

<p>블로그 용이성을 위해 웹용 vscode(vscode.dev)를 이용해서 블로깅을 해보려고 한다. 하지만 웹용 vscode의 경우 plantuml이나 mermaid uml을 실시간으로 볼 수 없는 불편함이 있는데 이때 웹용 에디터를 이용해서 작성하면 좀더 도움이 될듯 하다.</p>

<h3 id="plantuml용-웹-에디터">Plantuml용 웹 에디터</h3>

<p>웹을 이용한 Plantuml uml제작은 아래 주소에서 확인 할 수 있다.</p>

<p><a href="https://plantuml.com/ko/">https://plantuml.com/ko/</a></p>

<p><img src="/assets/images/2023/07/2023-07-05/01.png" alt="Plantuml Online Server" /></p>

<h4 id="해당-패이지는-plantuml의-설명서도-포함하고-있으므로-작성할-때-용이하다-하지만-인텔리-센스는-지원되지-않아-다소-불편">해당 패이지는 Plantuml의 설명서도 포함하고 있으므로 작성할 때 용이하다. (하지만 인텔리 센스는 지원되지 않아 다소 불편..)</h4>

<h3 id="mermaid용-웹-에디터">Mermaid용 웹 에디터</h3>

<p>웹을 이용한 Mermaid uml제작은 아래 주소에서 확인 할 수 있다.</p>

<p><a href="https://mermaid.js.org/">https://mermaid.js.org/</a></p>

<p><img src="/assets/images/2023/07/2023-07-05/02.png" alt="Mermaid Live Editor" /></p>

<h4 id="해당-패이지도-plantuml과-비슷하게-공홈이며-설명서도-포함하고-있으므로-작성할-때-용이하다-더불어-mermaid의-경우-라이브에디터에서도-인텔리센스가-지원된다">해당 패이지도 Plantuml과 비슷하게 공홈이며 설명서도 포함하고 있으므로 작성할 때 용이하다. 더불어 Mermaid의 경우 라이브에디터에서도 인텔리센스가 지원된다!</h4>]]></content><author><name>Seo Sang Hyok</name></author><category term="uml" /><category term="plantuml" /><category term="mermaid" /><summary type="html"><![CDATA[Plantuml, Mermaid 웹 에디터]]></summary></entry><entry><title type="html">Visual Studio 글꼴추천</title><link href="/visual/studio/2023/07/03/Visua_Studio_%EA%B8%80%EA%BC%B4%EC%B6%94%EC%B2%9C.html" rel="alternate" type="text/html" title="Visual Studio 글꼴추천" /><published>2023-07-03T00:00:00+00:00</published><updated>2023-07-03T00:00:00+00:00</updated><id>/visual/studio/2023/07/03/Visua_Studio_%EA%B8%80%EA%BC%B4%EC%B6%94%EC%B2%9C</id><content type="html" xml:base="/visual/studio/2023/07/03/Visua_Studio_%EA%B8%80%EA%BC%B4%EC%B6%94%EC%B2%9C.html"><![CDATA[<h2 id="visual-studio-추천-글꼴-consolas">Visual Studio 추천 글꼴 <strong>Consolas</strong></h2>

<p>visual studio 에 기본설정된 폰트로 작업을 하다보면 숫자 0과 영어대문자O 소문자 l(L)과 대문자 I(i)등 햇깔리는 경우가 많다. 이를 개선한 Consolas 폰트를 소개한다.</p>

<h3 id="설정-방법">설정 방법</h3>

<p>설정 방법은 [도구]-[옵션]-[글꼴 및 색] 항목의 [설정 표시] 에서 “택스트 편집기” 를 선택 한 후 Consolas 글꼴을 선택하면 된다.</p>

<p><img src="/assets/images/2023/07/2023-07-03/01.png" alt="설정이미지" /></p>

<h3 id="스크린-샷을-보면-햇깔릴수-있는-글꼴들이-잘-표시되는걸-볼-수-있다">스크린 샷을 보면 햇깔릴수 있는 글꼴들이 잘 표시되는걸 볼 수 있다.</h3>]]></content><author><name>Seo Sang Hyok</name></author><category term="visual" /><category term="studio" /><category term="visual studio" /><summary type="html"><![CDATA[Visual Studio 추천 글꼴 Consolas]]></summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="/jekyll/2018/12/07/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2018-12-07T00:00:00+00:00</published><updated>2018-12-07T00:00:00+00:00</updated><id>/jekyll/2018/12/07/welcome-to-jekyll</id><content type="html" xml:base="/jekyll/2018/12/07/welcome-to-jekyll.html"><![CDATA[<p>You’ll find this post in your <code class="language-plaintext highlighter-rouge">_posts</code> directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run <code class="language-plaintext highlighter-rouge">jekyll serve</code>, which launches a web server and auto-regenerates your site when a file is updated.</p>

<p>To add new posts, simply add a file in the <code class="language-plaintext highlighter-rouge">_posts</code> directory that follows the convention <code class="language-plaintext highlighter-rouge">YYYY-MM-DD-name-of-post.ext</code> and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.</p>

<h2 id="section-1">section 1</h2>

<p>Jekyll also offers powerful support for code snippets:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
<span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span></code></pre></figure>

<h2 id="section-2">section 2</h2>

<p>Check out the <a href="https://jekyllrb.com/docs/home">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs/feature requests at <a href="https://github.com/jekyll/jekyll">Jekyll’s GitHub repo</a>. If you have questions, you can ask them on <a href="https://talk.jekyllrb.com/">Jekyll Talk</a>.</p>

<p>$ a * b = c ^ b $</p>

<p>$ 2^{\frac{n-1}{3}} $</p>

<p>$ \int_a^b f(x)\,dx. $</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello World!"</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// prints 'Hi, Tom' to STDOUT.</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
    <span class="n">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="n">self</span><span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>

<span class="n">p1</span> <span class="o">=</span> <span class="nc">Person</span><span class="p">(</span><span class="sh">"</span><span class="s">John</span><span class="sh">"</span><span class="p">,</span> <span class="mi">36</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">age</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Jeffrey</name></author><category term="jekyll" /><category term="jekyll" /><category term="theme" /><category term="yat" /><summary type="html"><![CDATA[You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.]]></summary></entry><entry><title type="html">An exhibit of Markdown</title><link href="/markdown/2018/12/05/an-exhibit-of-markdown.html" rel="alternate" type="text/html" title="An exhibit of Markdown" /><published>2018-12-05T00:00:00+00:00</published><updated>2018-12-05T00:00:00+00:00</updated><id>/markdown/2018/12/05/an-exhibit-of-markdown</id><content type="html" xml:base="/markdown/2018/12/05/an-exhibit-of-markdown.html"><![CDATA[<p>This note demonstrates some of what <a href="https://daringfireball.net/projects/markdown/">Markdown</a> is capable of doing.</p>

<h2 id="an-exhibit-of-markdown">An exhibit of Markdown</h2>

<p><em>Note: Feel free to play with this page. Unlike regular notes, this doesn’t automatically save itself.</em></p>

<h2 id="basic-formatting">Basic formatting</h2>

<p>Paragraphs can be written like so. A paragraph is the basic block of Markdown. A paragraph is what text will turn into when there is no reason it should become anything else.</p>

<p>Paragraphs must be separated by a blank line. Basic formatting of <em>italics</em> and <strong>bold</strong> is supported. This <em>can be <strong>nested</strong> like</em> so.</p>

<h2 id="lists">Lists</h2>

<h3 id="ordered-list">Ordered list</h3>

<ol>
  <li>Item 1</li>
  <li>A second item</li>
  <li>Number 3</li>
  <li>Ⅳ</li>
</ol>

<p><em>Note: the fourth item uses the Unicode character for <a href="https://www.fileformat.info/info/unicode/char/2163/index.htm">Roman numeral four</a>.</em></p>

<h3 id="unordered-list">Unordered list</h3>

<ul>
  <li>An item</li>
  <li>Another item</li>
  <li>Yet another item</li>
  <li>And there’s more…</li>
</ul>

<h2 id="paragraph-modifiers">Paragraph modifiers</h2>

<h3 id="code-block">Code block</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Code blocks are very useful for developers and other people who look at code or other things that are written in plain text. As you can see, it uses a fixed-width font.
</code></pre></div></div>

<p>You can also make <code class="language-plaintext highlighter-rouge">inline code</code> to add code into other things.</p>

<h3 id="quote">Quote</h3>

<blockquote>
  <p>Here is a quote. What this is should be self explanatory. Quotes are automatically indented when they are used.</p>
</blockquote>

<h2 id="headings">Headings</h2>

<p>There are six levels of headings. They correspond with the six levels of HTML headings. You’ve probably noticed them already in the page. Each level down uses one more hash character.</p>

<h3 id="headings-can-also-contain-formatting">Headings <em>can</em> also contain <strong>formatting</strong></h3>

<h3 id="they-can-even-contain-inline-code">They can even contain <code class="language-plaintext highlighter-rouge">inline code</code></h3>

<p>Of course, demonstrating what headings look like messes up the structure of the page.</p>

<p>I don’t recommend using more than three or four levels of headings here, because, when you’re smallest heading isn’t too small, and you’re largest heading isn’t too big, and you want each size up to look noticeably larger and more important, there there are only so many sizes that you can use.</p>

<h2 id="urls">URLs</h2>

<p>URLs can be made in a handful of ways:</p>

<ul>
  <li>A named link to <a href="https://www.markitdown.net/">MarkItDown</a>. The easiest way to do these is to select what you want to make a link and hit <code class="language-plaintext highlighter-rouge">Ctrl+L</code>.</li>
  <li>Another named link to <a href="https://www.markitdown.net/">MarkItDown</a></li>
  <li>Sometimes you just want a URL like <a href="https://www.markitdown.net/">https://www.markitdown.net/</a>.</li>
</ul>

<h2 id="horizontal-rule">Horizontal rule</h2>

<p>A horizontal rule is a line that goes across the middle of the page.</p>

<hr />

<p>It’s sometimes handy for breaking things up.</p>

<h2 id="images">Images</h2>

<p>Markdown can also contain images. I’ll need to add something here sometime.</p>

<h2 id="finally">Finally</h2>

<p>There’s actually a lot more to Markdown than this. See the official <a href="https://daringfireball.net/projects/markdown/basics">introduction</a> and <a href="https://daringfireball.net/projects/markdown/syntax">syntax</a> for more information. However, be aware that this is not using the official implementation, and this might work subtly differently in some of the little things.</p>]]></content><author><name>Seo Sang Hyok</name></author><category term="markdown" /><category term="example" /><category term="markdown" /><summary type="html"><![CDATA[This note demonstrates some of what Markdown is capable of doing.]]></summary></entry><entry><title type="html">Mathjax Test</title><link href="/markdown/2018/05/26/mathjax-test.html" rel="alternate" type="text/html" title="Mathjax Test" /><published>2018-05-26T00:00:00+00:00</published><updated>2018-05-26T00:00:00+00:00</updated><id>/markdown/2018/05/26/mathjax-test</id><content type="html" xml:base="/markdown/2018/05/26/mathjax-test.html"><![CDATA[<ul>
  <li>A safe integer is an integer that
    <ul>
      <li>can be exactly represented as an IEEE-754 double precision number, and</li>
      <li>whose IEEE-75 representation cannot be the result of rounding any other integer to fit the IEEE-754 representation</li>
    </ul>
  </li>
  <li>For example, $ 2 ^ {53} - 1 $ is a safe integer,
    <ul>
      <li>it can be exactly represented</li>
    </ul>
  </li>
</ul>]]></content><author><name>Seo Sang Hyok</name></author><category term="markdown" /><category term="test" /><summary type="html"><![CDATA[A safe integer is an integer that can be exactly represented as an IEEE-754 double precision number, and whose IEEE-75 representation cannot be the result of rounding any other integer to fit the IEEE-754 representation For example, $ 2 ^ {53} - 1 $ is a safe integer, it can be exactly represented]]></summary></entry></feed>